import re
import javalang
from javalang.parser import JavaSyntaxError
from javalang.tokenizer import LexerError
from typing import List, Set

MAX_INTEGER = 2147483647
MIN_INTEGER = -2147483648


def extract_failed_method_names(maven_log, test_class_name):
    error_pattern = re.compile(rf"^\[ERROR\]\s+{re.escape(test_class_name)}\.(?P<method_name>[a-zA-Z0-9_]+):\d+", re.MULTILINE)

    failed_tests = []
    for line in maven_log.splitlines():
        match = error_pattern.match(line)
        print(f"{line}: {match}")
        if match:
            method_name = match.group("method_name")
            failed_tests.append(method_name)

    return failed_tests

def extract_failed_line_numbers(maven_log: str, class_name: str):
    escaped_filename = re.escape(class_name)
    pattern = re.compile(
        rf"^\s*\[ERROR\]\s+.*{escaped_filename}:\[(\d+),(\d+)\]",
        re.MULTILINE
    )
    matches = pattern.findall(maven_log)

    line_numbers = set()
    if matches:
        for num, _ in matches:
            line_numbers.add(int(num))

    return sorted(line_numbers)

def remove_method_from_class(class_code: str, method_name: str) -> str:
    lines = class_code.split('\n')
    new_class_code = []
    inside_method = False   # Indicate if we are inside the method to remove
    brackets_counter = 0

    for i, line in enumerate(lines):
        # If we are inside the method to remove
        if inside_method:
            # Count the number of opened "{" and closed "}" brackets to determine if the method has ended
            brackets_counter += line.count('{')
            brackets_counter -= line.count('}')

            # If the counter is 0, the method is ended
            if brackets_counter == 0:
                inside_method = False

            continue  # Skip the line

        # If we are outside the method to remove and the new line starts with the method declaration
        elif (f"public void {method_name}" in line or
                f"private void {method_name}" in line or
                f"protected void {method_name}" in line):
            inside_method = True
            brackets_counter = 0  # Reset brackets counter

            # If the previous line contains @Test, remove it
            if "@Test" in new_class_code[-1]:
                new_class_code.pop(-1)

            # If the line contains at least one token "{", we add to the counter
            if "{" in line:
                brackets_counter += line.count("{")

            continue  # Ignore the current signature line from the updated code

        # Else we add the line to the new code
        else:
            new_class_code.append(line)

    return '\n'.join(new_class_code)

def find_method_names_by_line_number(class_code: str, line_numbers: Set[int]) -> List[str]:
    lines = class_code.split('\n')
    method_line_pattern = re.compile(r'\b(public|private|protected)\s+\w+\s+(\w+)\s*\(.*?\)\s*\{?')
    method_name_pattern = re.compile(rf'\s*public\s+void\s+(\S+)(?=\()')

    methods_dict = {}
    for i, line in enumerate(lines):
        if method_line_pattern.search(line):
            methods_dict[i+1] = line

    failed_methods = []
    for line in line_numbers:
        closest = None
        for method_start_line in sorted(methods_dict.keys()):
            if method_start_line <= line:
                closest = method_start_line
            else:
                break

        if closest is not None:
            match = method_name_pattern.search(methods_dict[closest])

            if match:
                failed_methods.append(match.group(1))

    return failed_methods

########################## Cleanup functions to apply before executing heuristics ###########################
def apply_miscellaneous(model_in_use, prompt_in_use, test_code, test_class_prompt):
    cleaned_code = test_code
    if model_in_use == "Starcoder2-local":
        cleaned_code = cleanup_starcoder2(cleaned_code)

    if model_in_use == "chatgpt" and prompt_in_use == "prompt_1" and test_class_prompt not in cleaned_code:
        cleaned_code = add_missing_test_class_prompt(cleaned_code, test_class_prompt)

    return cleaned_code

# Remove non code string generated by Starcoder2 with prompt_2
def cleanup_starcoder2(test_code):
    return test_code.replace("The test class is as follows:", "")

def add_missing_test_class_prompt(test_code, test_class_prompt):
    pattern_class_signature = r"public\s+class\s+[\w$]+[\s\n\r]*\{"
    import_pattern = r"^\s*import\s+(?:[\w\.]+\s*)+;\s*$"

    prompt_class_signature = re.search(pattern_class_signature, test_class_prompt, re.MULTILINE)
    prompt_imports = re.findall(import_pattern, test_class_prompt, re.MULTILINE)
    class_signature = re.search(pattern_class_signature, test_code, re.MULTILINE)

    print(prompt_class_signature)
    print(prompt_imports)
    print(class_signature)

    if not prompt_class_signature:
        return test_code

    if class_signature:
        class_declaration = class_signature.group()

        test_code = test_code.replace(class_declaration, test_class_prompt)
    else:
        import_lines = re.findall(import_pattern, test_code, re.MULTILINE)
        print(import_lines)

        if import_lines:
            last_import = import_lines[-1]
            parts = test_code.split(last_import, 1)
            test_code = parts[0] + last_import + "\n" + test_class_prompt + "\n" + parts[1]
        else:
            test_code = test_class_prompt + "\n" + test_code

    print("result: ", test_code)
    return test_code


########################## Heuristics paper "Using Large Language Models to Generate JUnit Tests: An Empirical Study" ##########################
def apply_heuristics(model_in_use, prompt_in_use, test_code, java_class_prompt, test_class_prompt):
    test_code = remove_after_patterns(test_code)
    test_code = keep_code_in_backticks(test_code)
    test_code = remove_prompt_from_generated_test(test_code, java_class_prompt)
    test_code = replace_large_integers_with_parseInt(test_code)

    print("Applicazione funzioni di cleanup prima di euristica 'fix_incomplete_code'")
    test_code = apply_miscellaneous(model_in_use, prompt_in_use, test_code, test_class_prompt)

    test_code = fix_incomplete_code(test_code)
    return test_code

def remove_after_patterns(code):
    patterns = [r"</code>", r"\n\n// \{CUT_[a-zA-Z0-9_]+\}", r"\n```\n\n##"]
    for pattern in patterns:
        code = re.sub(pattern + r".*", "", code, flags=re.DOTALL)
    return code

def keep_code_in_backticks(code):
    # Try to capture ```java ... ``` blocks
    java_snippets = re.findall(r"```java(.*?)```", code, flags=re.DOTALL)
    if java_snippets:
        return "\n".join(s.strip() for s in java_snippets)
    else:
        # Try to capture generic blocks ```...```
        generic_snippets = re.findall(r"```(.*?)```", code, flags=re.DOTALL)
        if generic_snippets:
            return "\n".join(s.strip() for s in generic_snippets)

    return code


def remove_prompt_from_generated_test(code, prompt):
    return code.replace(prompt, "")

def replace_large_integers_with_parseInt(code):
    # uses javalang to find all number constants in the code
    try:
        tokens = javalang.tokenizer.tokenize(code)
        previous_line, previous_end, new_code, last_val = 1, 0, "", None
        applied_heuristic = False
        for token in tokens:
            line, column = token.position
            if line != previous_line:
                new_code += "\n"
                new_code += " " * (column - 1)
            else:
                new_code += " " * (column - previous_end)

            if isinstance(token, javalang.tokenizer.DecimalInteger):
                num_value = int(token.value[:-1]) if "L" in token.value.upper() else int(token.value)
                if num_value > MAX_INTEGER or (last_val == '-' and -1 * num_value < MIN_INTEGER):
                    if "L" in token.value.upper():
                        replacement = 'Long.parseLong("%s")' % token.value[:-1]
                    else:
                        replacement = 'Integer.parseInt("%s")' % token.value
                    new_code += replacement
                    applied_heuristic = True
                else:
                    new_code += token.value
            else:
                new_code += token.value
            previous_line = line
            previous_end = column + len(token.value)
            last_val = token.value

        return new_code if applied_heuristic else code
    except:
        return code

def fix_incomplete_code(code: str):
    # if the code is valid, return it
    cu = parse_code(code)
    if cu:
        return code
    # otherwise, try to fix it
    new_code = code
    num_lines = new_code.count("\n")
    # test prompt is length of 14, so we try to fix the code by removing lines until we reach 10
    while num_lines > 14:
        # append two curly brackets
        cu = parse_code(new_code + "\n}\n}")
        if cu:
            return new_code + "\n}\n}"

        # append one curly bracket
        cu = parse_code(new_code + "\n}")
        if cu:
            return new_code + "\n}"

        # remove the last line
        new_code = new_code[:new_code.rfind("\n")]
        num_lines -= 1

        # append two curly brackets
        cu = parse_code(new_code + "\n}\n}")
        if cu:
            return new_code + "\n}\n}"
        # append one curly bracket
        cu = parse_code(new_code + "\n}")
        if cu:
            return new_code + "\n}"

    # if we reach here, the code is still unfixable
    return None

def parse_code(code):
    try:
        return javalang.parse.parse(code)  # code is compilable
    except (JavaSyntaxError, LexerError, TypeError, RecursionError) as e:
        return False